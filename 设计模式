设计模式
可维护 克服用法 可扩展 灵活型号 
通过封装、继承、多态把程序的耦合性降低
类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类 
单一职责原则(SRP)：就一个类而言，应该仅有一个引起它变化的原因
依赖倒置原则： 针对接口编程，不要针对实现编程
A.高层模块不应该依赖低层模块，两个都应该依赖抽象
B.抽象不应该依赖细节，细节应该依赖抽象
装饰模式： 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
代理模式： 为其他对象提供一种代理以控制对这个对象的访问。
代理类就是持有一个真实类的引用，调用实际类的方法。 代理类和实际类通过实现相同接口达到统一。
远程代理：也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。

简单工厂模式 VS 工厂方法模式 IFactory factory = new UndergraduateFactory();  LeiFeng student = factory.CreateLeiFeng();
外观模式(Facade): 为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

